#!/usr/bin/python3
# SPDX-License-Identifier: AGPL-3.0-or-later

import argparse
import logging
import os
import sys

logger = logging.getLogger(__name__)

EXIT_SYNTAX = 10
EXIT_PERM = 20


def reserved_for_root(fun):
    def wrapped(*args, **kwargs):
        if os.getuid() != 0:
            logger.critical('This action is reserved for root')
            sys.exit(EXIT_PERM)
        return fun(*args, **kwargs)
    return wrapped


def main():
    parser = argparse.ArgumentParser()
    group = parser.add_mutually_exclusive_group(required=True)
    group.add_argument('-i', nargs=2, dest='ipc')
    group.add_argument('-t', nargs=1, dest='touch_file')

    adict = vars(parser.parse_args())
    generator = (kv for kv in adict.items() if kv[1] is not None)
    subcommand, arguments = next(generator)

    function = globals()['subcommand_' + subcommand]
    function(*arguments)


@reserved_for_root
def subcommand_ipc(module_name, action_name):
    import plinth.modules.email_server.audit as audit

    # We only run actions defined in the audit module
    if module_name not in audit.__all__:
        logger.critical('Bad module name: %r', module_name)
        sys.exit(EXIT_SYNTAX)

    module = getattr(audit, module_name)
    function = getattr(module, 'action_' + action_name, None)
    if function is None:
        logger.critical('Bad action: %s/%r', module_name, action_name)
        sys.exit(EXIT_SYNTAX)

    function()


def subcommand_touch_file(path):
    import pathlib

    if os.getuid == 0:
        logger.critical('Do not run as root')
        sys.exit(EXIT_PERM)

    # mode is influenced by umask
    pathlib.Path(path).touch(mode=0o660, exist_ok=True)


if __name__ == '__main__':
    main()
